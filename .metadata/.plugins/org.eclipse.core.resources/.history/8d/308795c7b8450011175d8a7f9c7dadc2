package de.uni_stuttgart.ipvs.ids.communication;

import java.io.BufferedInputStream;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.SocketAddress;
import java.util.Collection;
import java.util.Vector;

import de.uni_stuttgart.ipvs.ids.replication.VersionedValue;
import de.uni_stuttgart.ipvs.ids.replication.VersionedValueWithSource;

/**
 * Part b) Extend the method receiveMessages to return all DatagramPackets that
 * were received during the given timeout.
 * 
 * Also implement unpack() to conveniently convert a Collection of
 * DatagramPackets containing ValueResponseMessages to a collection of
 * VersionedValueWithSource objects.
 * 
 */
public class NonBlockingReceiver {

	protected DatagramSocket socket;

	public NonBlockingReceiver(DatagramSocket socket) {
		this.socket = socket;
	}

	/**
	 * Wait for a specified time (timeoutMillis) for Messages. This is done
	 * by setting the socket SO Timeout to 1. So we check every ms if a new
	 * message has been received until we hit timeout.
	 * 
	 * @param timeoutMillis
	 * @return
	 * @throws IOException
	 * @throws ClassNotFoundException
	 */
	public Vector<DatagramPacket> receiveMessages(int timeoutMillis)
			throws IOException, ClassNotFoundException {
		// Set Timeout
		socket.setSoTimeout(1);
		// Create local vector & packet dummy
		Vector<DatagramPacket> packets = new Vector<DatagramPacket>();
		byte[] q = new byte[16384];
		DatagramPacket packet = new DatagramPacket(q, q.length);
		ByteArrayInputStream byteStream = null;
		ObjectInputStream is = null;
		// Set Timer & repeat until time == 0
		int time = timeoutMillis;
		while (time > 0) {
			// try receiving a message
			try {
				socket.receive(packet);
				byteStream = new ByteArrayInputStream(q);
			    is = new ObjectInputStream(new BufferedInputStream(byteStream));
			    packets.add(packet);
			    is.close();
			}catch (IOException e) {
				// Do nothing if no message has been received
			}
			// Count Time
		    time--;
		}
		// Return
	    return packets;
	}

	/**
	 * 
	 * @param packetCollection
	 * @return
	 * @throws IOException
	 * @throws ClassNotFoundException
	 */
	public static <T> Vector<VersionedValueWithSource<T>> unpack(
			Collection<DatagramPacket> packetCollection) throws IOException,
			ClassNotFoundException {
		// Create Local Vector & stuff
		ByteArrayInputStream byteStream = null;
		ObjectInputStream is = null;
		Vector<VersionedValueWithSource<T>> vector = new Vector<VersionedValueWithSource<T>>();
		// Convert each packet
		for (DatagramPacket packet : packetCollection) {
			SocketAddress adr = packet.getSocketAddress();
			byteStream = new ByteArrayInputStream(packet.getData());
		    is = new ObjectInputStream(new BufferedInputStream(byteStream));
		    VersionedValue<T> object = (VersionedValue<T>) is.readObject();
		    is.close();
		    vector.add(new VersionedValueWithSource(object,adr));
		}
		return vector;
	}
}
