package de.uni_stuttgart.ipvs.ids.communication;

import java.io.BufferedInputStream;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.InetAddress;
import java.net.SocketAddress;
import java.net.SocketException;
import java.net.SocketTimeoutException;
import java.util.Collection;
import java.util.Vector;

import de.uni_stuttgart.ipvs.ids.replication.VersionedValue;
import de.uni_stuttgart.ipvs.ids.replication.VersionedValueWithSource;

/**
 * Part b) Extend the method receiveMessages to return all DatagramPackets that
 * were received during the given timeout.
 * 
 * Also implement unpack() to conveniently convert a Collection of
 * DatagramPackets containing ValueResponseMessages to a collection of
 * VersionedValueWithSource objects.
 * 
 */
public class NonBlockingReceiver {

	protected DatagramSocket socket;

	public NonBlockingReceiver(DatagramSocket socket) {
		this.socket = socket;
	}

	public Vector<DatagramPacket> receiveMessages(int timeoutMillis)
			throws IOException, ClassNotFoundException {
		// Set Timeout
		socket.setSoTimeout(1);
		// Create local vector & packet dummy
		Vector<DatagramPacket> packets = new Vector<DatagramPacket>();
		byte[] q = new byte[16384];
		DatagramPacket packet = new DatagramPacket(q, q.length);
		ByteArrayInputStream byteStream = null;
		ObjectInputStream is = null;
		// Set Timer
		int time = timeoutMillis;
		while (time > 0) {
			try {
				socket.receive(packet);
				byteStream = new ByteArrayInputStream(q);
			    is = new ObjectInputStream(new BufferedInputStream(byteStream));
			    packets.add(packet);
			    is.close();
			}catch (IOException e) {
			}
		    time--;
		}
		// Return
		System.out.println(packets.size());
	    return packets;
	}

	public static <T> Vector<VersionedValueWithSource<T>> unpack(
			Collection<DatagramPacket> packetCollection) throws IOException,
			ClassNotFoundException {
		// Create Local Vector & stuff
		ByteArrayInputStream byteStream = null;
		ObjectInputStream is = null;
		Vector<VersionedValueWithSource<T>> vector = new Vector<VersionedValueWithSource<T>>();
		// Convert each packet
		for (DatagramPacket packet : packetCollection) {
			SocketAddress adr = packet.getSocketAddress();
			byteStream = new ByteArrayInputStream(packet.getData());
		    is = new ObjectInputStream(new BufferedInputStream(byteStream));
		    VersionedValue<T> object = (VersionedValue<T>) is.readObject();
		    is.close();
		    vector.add(new VersionedValueWithSource(object,adr));
		}
		return vector;
	}
}
